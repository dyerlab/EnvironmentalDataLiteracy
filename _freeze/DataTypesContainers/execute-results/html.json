{
  "hash": "9f5e22027eadb7a19d2012bbd855d3ce",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Types & Containers\n\n![](media/RRC_MilkyClose.jpg)\n\n> The data we work with comes in many forms—integers, stratum, categories, genotypes, etc.—all of which we need to be able to work with in our analyses. In this chapter, the basic data types we will commonly use in population genetic analyses.  This section covers some of the basic types of data we will use in R.  These include numbers, character, factors, and logical data types.  We will also introduce the locus object from the gstudio library and see how it is just another data type that we can manipulate in R.\n\nThe very first hurdle you need to get over is the oddness in the way in which R assigns values to variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- value\n```\n:::\n\n\nYes that is a less-than and dash character.  This is the assignment operator that historically has been used and it is the one that I will stick with.  In some cases you can use the '=' to assign variables instead but then it takes away the R-ness of R itself.  For decision making, the equality operator (e.g., is this equal to that) is the double equals sign '=='.  We will get into that below where we talk about logical types and later in decision making.\n\nIf you are unaware of what type a particular variable may be, you can always use the `type()` function and R will tell you.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass( variable )\n```\n:::\n\n\nR also has a pretty good help system built into itself.  You can get help for any function by typing a question mark in front of the function name.  This is a particularly awesome features because at the end of the help file, there is often examples of its usage, which are priceless.  Here is the documentation for the 'help' function as given by:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?help\n```\n:::\n\n\nThere are also package vignettes available (for most packages you download) that provide additional information on the routines, data sets, and other items included in these packages. You can get a list of vignettes currently installed on your machine by:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvignette()\n```\n:::\n\n\nand vignettes for a particular package by passing the package name as an argument to the function itself.\n\n## Numeric Data Types\n\nThe quantitative measurements we make are often numeric, in that they can be represented as as a number with a decimal component (think weight, height, latitude, soil moisture, ear wax viscosity, etc.).  The most basic type of data in R, is the numeric type and represents both integers and floating point numbers (n.b., there is a strict integer data type but it is often only needed when interfacing with other C libraries and can for what we are doing be disregarded).\n\nAssigning a value to a variable is easy\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nBy default, R automatically outputs whole numbers numbers within decimal values appropriately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 22/7\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.142857\n```\n\n\n:::\n:::\n\n\nIf there is a mix of whole numbers and numbers with decimals together in a container such as\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(x,y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.000000 3.142857\n```\n\n\n:::\n:::\n\n\nthen both are shown with decimals. The `c()` part here is a function that combines several data objects together into a vector and is very useful.  In fact, the use of vectors are are central to working in R and functions almost all the functions we use on individual variables can also be applied to vectors.\n\nA word of caution should be made about numeric data types on any computer.  Consider the following example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- .3 / 3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1\n```\n\n\n:::\n:::\n\n\nwhich is exactly what we'd expect.  However, the way in which computers store decimal numbers plays off our notion of significant digits pretty well.  Look what happens when I print out x but carry out the number of decimal places.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(x, digits=20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.099999999999999991673\n```\n\n\n:::\n:::\n\n\nNot quite 0.1 is it?  Not that far away from it but not exact.  That is a general problem, not one that R has any more claim to than any other language and/or implementation.  Does this matter much, probably not in the realm of the kinds of things we do in population genetics, it is just something that you should be aware of.\nYou can make random sets of numeric data by using using functions describing various distributions.  For example, some random numbers from the normal distribution are:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0.1672189  1.0475240  0.3313410  0.9603622 -0.1519597 -2.5112776\n [7] -1.8041684 -1.0600132 -0.5569387 -0.9205846\n```\n\n\n:::\n:::\n\n\nfrom the normal distribution with designated mean and standard deviation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(10,mean=42,sd=12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 50.28551 48.60337 22.18270 41.34702 34.58415 14.66586 47.76293 40.62223\n [9] 42.37023 38.97201\n```\n\n\n:::\n:::\n\n\nA poisson distribution with mean 2:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrpois(10,lambda = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 2 2 2 0 2 3 3 1 2 0\n```\n\n\n:::\n:::\n\n\nand the $\\chi^2$ distribution with 1 degree of freedom:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrchisq(10, df=1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1.631124e-01 4.978950e+00 2.006288e-01 1.057546e-06 9.656761e-02\n [6] 2.267763e+00 3.363315e-02 4.054664e-03 2.007249e-01 1.688059e-01\n```\n\n\n:::\n:::\n\n\nThere are several more distributions that if you need to access random numbers, quantiles, probability densities, and cumulative density values are available.\n\n### Coercion to Numeric\n\nAll data types have the potential ability to take another variable and coerce it into their type.  Some combinations make sense, and some do not.  For example, if you load in a CSV data file using read_csv(), and at some point a stray non-numeric character was inserted into one of the cells on your spreadsheet, R will interpret the entire column as a character type rather than as a numeric type.  This can be a very frustrating thing, spreadsheets should generally be considered evil as they do all kinds of stuff behind the scenes and make your life less awesome.\n\nHere is an example of coercion of some data that is initially defined as a set of characters\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"42\",\"99\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"42\" \"99\"\n```\n\n\n:::\n:::\n\n\nand is coerced into a numeric type using the as.numeric() function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.numeric( x )\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42 99\n```\n\n\n:::\n:::\n\n\n\nIt is a built-in feature of the data types in R that they all have (or should have if someone is producing a new data type and is being courteous to their users) an `as.X()` function.  This is where the data type decides if the values asked to be coerced are reasonable or if you need to be reminded that what you are asking is not possible.  Here is an example where I try to coerce a non-numeric variable into a number.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"The night is dark and full of terrors...\"\nas.numeric( x )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\nBy default, the result should be NA (missing data/non-applicable) if you ask for things that are not possible.\n\n## Character Data\n\nA collection of letters, number, and or punctuation is represented as a character data type.  These are enclosed in either single or double quotes and are considered a single entity.  For example, my name can be represented as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprof <- \"Rodney J. Dyer\"\nprof\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rodney J. Dyer\"\n```\n\n\n:::\n:::\n\n\nIn R, character variables are considered to be a single entity, that is the entire prof variable is a single unit, not a collection of characters.  This is in part due to the way in which vectors of variables are constructed in the language.  For example, if you are looking at the length of the variable I assigned my name to you see\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(prof)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\nwhich shows that there is only one 'character' variable.  If, as is often the case, you are interested in knowing how many characters are in the variable prof, then you use the\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnchar(prof)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14\n```\n\n\n:::\n:::\n\n\n\nfunction instead.  This returns the number of characters (even the non-printing ones like tabs and spaces.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnchar(\" \\t \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nAs all other data types, you can define a vector of character values using the `c()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"I am\"\ny <- \"not\"\nz <- 'a looser'\nterms <- c(x,y,z)\nterms\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I am\"     \"not\"      \"a looser\"\n```\n\n\n:::\n:::\n\n\nAnd looking at the `length()` and `nchar()` of this you can see how these operations differ.\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(terms)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nnchar(terms)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 3 8\n```\n\n\n:::\n:::\n\n\n\n### Concatenation of Characters\n\nAnother common use of characters is concatenating them into single sequences.  Here we use the function `paste()` and can set the separators (or characters that are inserted between entities when we collapse vectors).  Here is an example, entirely fictional and only provided for instructional purposes only.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(terms, collapse=\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I am not a looser\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(x,z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I am a looser\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(x,z,sep=\" not \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"I am not a looser\"\n```\n\n\n:::\n:::\n\n\n### Coercion to Characters\n\nA character data type is often the most basal type of data you can work with.  For example, consider the case where you have named sample locations.  These can be kept as a character data type or as a factor (see below).  There are benefits and drawbacks to each representation of the same data (see below).  By default (as of the version of R I am currently using when writing this book), if you use a function like read_table() to load in an external file, columns of character data will be treated as factors.  This can be good behavior if all you are doing is loading in data and running an analysis, or it can be a total pain in the backside if you are doing more manipulative analyses.\n\nHere is an example of coercing a numeric type into a character type using the `as.character()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 42\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.character(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"42\"\n```\n\n\n:::\n:::\n\n\n\n\n## Logical Types\n\nA logical type is either TRUE or FALSE, there is no in-between.  It is common to use these types in making decisions (see if-else decisions) to check a specific condition being satisfied.  To define logical variables you can either use the TRUE or FALSE directly\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncanThrow <- c(FALSE, TRUE, FALSE, FALSE, FALSE)\ncanThrow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nor can implement some logical condition\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstable <- c( \"RGIII\" == 0, nchar(\"Marshawn\") == 8)\nstable\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE\n```\n\n\n:::\n:::\n\n\non the variables.  Notice here how each of the items is actually evaluated as to determine the truth of each expression.  In the first case, the character is not equal to zero and in the second, the number of characters (what `nchar()` does) is indeed equal to 8 for the character string \"Marshawn\".\n\nIt is common to use logical types to serve as indices for vectors.  Say for example, you have a vector of data that you want to select some subset from.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- rnorm(20)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -0.58928739 -1.71437217 -1.68162943  1.89620753 -0.54817003  1.41173564\n [7]  2.33212561  1.02421254  1.39568316 -1.13489794 -1.01138782 -1.02686297\n[13] -1.25141743 -1.60931891 -0.26138790 -0.15815495 -0.05338385  0.60971443\n[19] -1.13809800 -2.03698357\n```\n\n\n:::\n:::\n\n\n\nPerhaps you are on interested in the non-negative values\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[ data > 0 ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.8962075 1.4117356 2.3321256 1.0242125 1.3956832 0.6097144\n```\n\n\n:::\n:::\n\n\nIf you look at the condition being passed to as the index\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata > 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nyou see that individually, each value in the data vector is being evaluated as a logical value, satisfying the condition that it is strictly greater than zero.  When you pass that as indices to a vector it only shows the indices that are `TRUE`.\n\nYou can coerce a value into a logical if you understand the rules.  Numeric types that equal 0 (zero) are `FALSE`, always.  Any non-zero value is considered `TRUE`.  Here I use the modulus operator, `%%`, which provides the remainder of a division.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:20 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0\n```\n\n\n:::\n:::\n\n\nwhich used as indices give us\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[ (1:20 %% 2) > 0 ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -0.58928739 -1.68162943 -0.54817003  2.33212561  1.39568316 -1.01138782\n [7] -1.25141743 -0.26138790 -0.05338385 -1.13809800\n```\n\n\n:::\n:::\n\n\nYou can get as complicated in the creation of indices as you like, even using logical operators such as OR and AND. I leave that as an example for you to play with.\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}